/*
 * Copyright (c) 2020 The ZMK Contributors
 *
 * SPDX-License-Identifier: MIT
 */

#define DT_DRV_COMPAT zmk_behavior_sticky_mods

#include <zephyr/device.h>
#include <drivers/behavior.h>
#include <zephyr/logging/log.h>

#include <zmk/event_manager.h>
#include <zmk/events/keycode_state_changed.h>
#include <zmk/behavior.h>
#include <zmk/hid.h>
#include <zmk/keymap.h>

LOG_MODULE_DECLARE(zmk, CONFIG_ZMK_LOG_LEVEL);

#if DT_HAS_COMPAT_STATUS_OKAY(DT_DRV_COMPAT)

struct sticky_mods_state {
    bool active;
    uint32_t param1;
    uint8_t self_activation_count;
    zmk_mod_flags_t modifiers;
    uint32_t overlay_layer;
};

struct sticky_mods_state sticky_mods_state = {};

zmk_mod_flags_t zmk_behaviors_sticky_mods_get_current_combo() {
    return sticky_mods_state.modifiers;
}

static int behavior_sticky_mods_init(const struct device *dev) { return 0; };

static int on_sticky_mods_binding_pressed(struct zmk_behavior_binding *binding,
                                          struct zmk_behavior_binding_event event) {
    sticky_mods_state.active = true;
    sticky_mods_state.param1 = binding->param1;
    sticky_mods_state.self_activation_count = 0;
    sticky_mods_state.overlay_layer = binding->param2;

    // Press the key
    raise_zmk_keycode_state_changed_from_encoded(binding->param1, true, event.timestamp);

    // Snapshot of currently held modifiers
    sticky_mods_state.modifiers |= zmk_hid_get_keyboard_report()->body.modifiers;
    LOG_DBG("current modifiers 0x%02X", sticky_mods_state.modifiers);

    // Release the key
    raise_zmk_keycode_state_changed_from_encoded(binding->param1, false, event.timestamp);

    // Enable the sticky layer
    return zmk_keymap_layer_activate(sticky_mods_state.overlay_layer);
}

static int on_sticky_mods_binding_released(struct zmk_behavior_binding *binding,
                                           struct zmk_behavior_binding_event event) {
    return ZMK_BEHAVIOR_OPAQUE;
}

/* #region Keycode state listener */

static int sticky_mods_keycode_state_changed_listener(const zmk_event_t *eh);

ZMK_LISTENER(behavior_sticky_mods, sticky_mods_keycode_state_changed_listener);
ZMK_SUBSCRIPTION(behavior_sticky_mods, zmk_keycode_state_changed);

static int sticky_mods_keycode_state_changed_listener(const zmk_event_t *eh) {
    struct zmk_keycode_state_changed *ev = as_zmk_keycode_state_changed(eh);
    if (ev == NULL || !sticky_mods_state.active) {
        return ZMK_EV_EVENT_BUBBLE;
    }

    if (ev->state) { // key down
        if (ZMK_HID_USAGE_ID(sticky_mods_state.param1) == ev->keycode &&
            ZMK_HID_USAGE_PAGE(sticky_mods_state.param1) == ev->usage_page) {
            sticky_mods_state.self_activation_count += 1;

            if (sticky_mods_state.self_activation_count == 1) {
                // don't catch key down events generated by the sticky key behavior itself
                return ZMK_EV_EVENT_BUBBLE;
            }
        }

        // Inject modifiers snapshot and fire the pressed keys
        struct zmk_keycode_state_changed_event duped_ev = copy_raised_zmk_keycode_state_changed(ev);
        duped_ev.data.implicit_modifiers |= sticky_mods_state.modifiers;
        ZMK_EVENT_RELEASE(duped_ev);

        LOG_DBG("sticky_mods releasing %d", ev->keycode);

        sticky_mods_state.active = false;
        // Deactivate the overlay layer
        zmk_keymap_layer_deactivate(sticky_mods_state.overlay_layer);

        // Reset the modifiers snapshot
        sticky_mods_state.modifiers = 0;

        return ZMK_EV_EVENT_CAPTURED;
    }

    return ZMK_EV_EVENT_BUBBLE;
}

/* #endregion */

static const struct behavior_driver_api behavior_sticky_mods_driver_api = {
    .binding_pressed = on_sticky_mods_binding_pressed,
    .binding_released = on_sticky_mods_binding_released,
};

#define KP_INST(n)                                                                                 \
    BEHAVIOR_DT_INST_DEFINE(n, behavior_sticky_mods_init, NULL, NULL, NULL, POST_KERNEL,           \
                            CONFIG_KERNEL_INIT_PRIORITY_DEFAULT,                                   \
                            &behavior_sticky_mods_driver_api);

DT_INST_FOREACH_STATUS_OKAY(KP_INST)

#endif /* DT_HAS_COMPAT_STATUS_OKAY(DT_DRV_COMPAT) */